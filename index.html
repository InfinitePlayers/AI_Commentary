<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fortnite AI Commentator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Using the stable TMI.js script from your example -->
    <script src="https://cdn.jsdelivr.net/gh/InfinitePlayers/tmi@main/tmi.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117;
            color: #e6e6e6;
        }
        .card {
            background-color: #161b22;
            border: 1px solid #30363d;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
        }
        .neon-text {
            color: #38bdf8; /* Tailwind sky-400 */
            text-shadow: 0 0 5px rgba(56, 189, 248, 0.7), 0 0 10px rgba(56, 189, 248, 0.5);
        }
        .btn-primary {
            background-color: #10b981; /* Tailwind emerald-500 */
            color: #0d1117;
            font-weight: bold;
            transition: all 0.2s ease-in-out;
            border: 2px solid transparent;
        }
        .btn-primary:hover:not(:disabled) {
            background-color: #059669; /* Tailwind emerald-600 */
            box-shadow: 0 0 15px rgba(16, 185, 129, 0.5);
        }
        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-secondary {
            background-color: #3b82f6; /* blue-500 */
            color: white;
        }
        .btn-secondary:hover:not(:disabled) {
            background-color: #2563eb; /* blue-600 */
        }
        .btn-secondary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-danger {
            background-color: #ef4444; /* red-500 */
            color: white;
        }
        .btn-danger:hover:not(:disabled) {
            background-color: #dc2626; /* red-600 */
        }
        .commentary-output {
            background-color: #1f2a37;
            border-left: 5px solid #38bdf8;
            padding: 1rem;
            min-height: 80px;
            transition: all 0.3s ease;
        }
        .scene-container {
            position: relative;
            width: 100%;
            padding-top: 56.25%; /* 16:9 Aspect Ratio */
            background-color: #1f2a37;
        }
        .game-screen-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 0.5rem;
        }
        .pulsing {
            animation: pulse-border 1.5s infinite alternate;
        }
        @keyframes pulse-border {
            from { border-color: #38bdf8; box-shadow: 0 0 5px #38bdf8; }
            to { border-color: #10b981; box-shadow: 0 0 15px #10b981; }
        }
        .caster-box-active { /* Game */
            border-color: #10b981 !important; /* Green */
            box-shadow: 0 0 15px rgba(16, 185, 129, 0.5);
        }
        .caster-box-chat { /* Chat */
             border-color: #f59e0b !important; /* Amber */
             box-shadow: 0 0 15px rgba(245, 158, 11, 0.5);
        }
        .caster-box-streamer { /* Mic */
             border-color: #a855f7 !important; /* Purple */
             box-shadow: 0 0 15px rgba(168, 85, 247, 0.5);
        }
        .caster-box-error {
            border-left-color: #ef4444 !important; /* red-500 */
        }
        /* STT Output Box */
        .stt-output {
            background-color: #1f2a37;
            border-left: 5px solid #a855f7; /* Purple */
            padding: 1rem;
            min-height: 60px;
            font-style: italic;
        }
        /* Twitch Chat Box */
        #chat-feed-box {
            background-color: #0d1117;
            height: 200px;
            overflow-y: auto;
            border: 1px solid #30363d;
            border-radius: 0.5rem;
            padding: 0.75rem;
            font-size: 0.875rem;
        }
        #chat-feed-box p {
            margin-bottom: 0.5rem;
            word-break: break-word;
        }
        #chat-feed-box p:last-child {
            margin-bottom: 0;
        }
        .chat-username {
            font-weight: 700;
        }
        /* Twitch Status */
        .status-disconnected {
            color: #ef4444; /* red-500 */
            font-weight: bold;
        }
        .status-connecting {
            color: #f59e0b; /* amber-500 */
            font-weight: bold;
        }
        .status-connected {
            color: #10b981; /* emerald-500 */
            font-weight: bold;
        }
        /* Tooltip styles */
        .info-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            width: max-content;
            max-width: 250px;
            padding: 8px;
            font-size: 0.75rem;
            color: white;
            background-color: #1f2a37; /* Use a dark background */
            border: 1px solid #30363d;
            border-radius: 6px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
            pointer-events: none; /* So it doesn't block hover */
        }
        .relative:hover .info-tooltip {
            opacity: 1;
        }
    </style>
</head>
<body class="min-h-screen p-4">
    <div id="app" class="w-full max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-3 gap-6">
        
        <!-- Left Column: Setup & Twitch -->
        <div class="lg:col-span-1 space-y-6">
            <header class="text-center">
                <h1 class="text-4xl sm:text-5xl font-extrabold neon-text">AI Fortnite Caster</h1>
                <p class="text-lg text-gray-400 mt-2">Stable Single-Commentator</p>
            </header>

            <!-- Setup Card -->
            <div id="setup-card" class="card rounded-xl p-4 space-y-4">
                <h2 class="text-xl font-bold text-gray-300 mb-2">Streaming Setup</h2>
                
                <div>
                    <label for="api-key-input" class="block text-sm font-medium text-gray-400 mb-1 flex items-center gap-1">
                        <span>Gemini API Key</span>
                        <!-- Tooltip Start -->
                        <div class="relative">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4 text-gray-500 cursor-pointer"><path fill-rule="evenodd" d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-7-4a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM9 9a1 1 0 0 0 0 2v3a1 1 0 0 0 1 1h1a1 1 0 1 0 0-2v-3a1 1 0 0 0-1-1H9Z" clip-rule="evenodd" /></svg>
                            <span class="info-tooltip">
                                Your private API key from Google AI Studio. This is saved *only* in your browser and is never shared.
                            </span>
                        </div>
                        <!-- Tooltip End -->
                    </label>
                    <input type="password" id="api-key-input" placeholder="Enter your Gemini API key" class="w-full p-2 rounded-md bg-gray-700 text-white border border-gray-600">
                    <p class="text-xs text-gray-500 mt-1">Your key is saved locally to your browser and never shared.</p>
                    <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-xs text-sky-400 hover:text-sky-300 transition-colors duration-200">Get your free Gemini API key here</a>
                </div>

                <!-- Device Setup -->
                <div class="space-y-4">
                    <div>
                        <label for="video-input-select" class="block text-sm font-medium text-gray-400 mb-1 flex items-center gap-1">
                            <span>Camera / Game Feed</span>
                            <!-- Tooltip Start -->
                            <div class="relative">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4 text-gray-500 cursor-pointer"><path fill-rule="evenodd" d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-7-4a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM9 9a1 1 0 0 0 0 2v3a1 1 0 0 0 1 1h1a1 1 0 1 0 0-2v-3a1 1 0 0 0-1-1H9Z" clip-rule="evenodd" /></svg>
                                <span class="info-tooltip">
                                    Select your OBS Virtual Camera or screen capture source. Click 'Activate' to see the feed.
                                </span>
                            </div>
                            <!-- Tooltip End -->
                        </label>
                        <div class="flex gap-2">
                            <select id="video-input-select" class="w-full flex-1 p-2 rounded-md bg-gray-700 text-white border border-gray-600"></select>
                            <button id="activate-camera-btn" class="btn-secondary p-2 rounded-lg shadow-lg" onclick="activateCamera()">
                                Activate
                            </button>
                        </div>
                    </div>
                    
                    <div class="bg-gray-800 p-3 rounded-lg border border-gray-700">
                        <h4 class="text-sm font-bold text-sky-300 mb-2 flex items-center gap-1">
                            <span>Pro Tip for OBS Audio</span>
                            <!-- Tooltip Start -->
                            <div class="relative">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4 text-gray-500 cursor-pointer"><path fill-rule="evenodd" d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-7-4a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM9 9a1 1 0 0 0 0 2v3a1 1 0 0 0 1 1h1a1 1 0 1 0 0-2v-3a1 1 0 0 0-1-1H9Z" clip-rule="evenodd" /></svg>
                                <span class="info-tooltip">
                                    This app uses your browser's "instant" speech. It will always play on your system's default audio output. This method ensures OBS captures it.
                                </span>
                            </div>
                            <!-- Tooltip End -->
                        </h4>
                        <p class="text-xs text-gray-400 leading-relaxed">
                            This app's audio plays from Chrome. The easiest way to capture it in OBS is:
                            <br><strong>On Windows:</strong> Add a new `Application Audio Capture` source and select Chrome.
                            <br><strong>On macOS:</strong> Add a new `macOS Screen Capture` source, set Mode to `Window Capture`, and choose this Chrome tab.
                        </p>
                    </div>
                </div>

                <!-- Game Settings -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label for="game-mode-select" class="block text-sm font-medium text-gray-400 mb-1 flex items-center gap-1">
                            <span>Game Mode</span>
                            <!-- Tooltip Start -->
                            <div class="relative">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4 text-gray-500 cursor-pointer"><path fill-rule="evenodd" d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-7-4a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM9 9a1 1 0 0 0 0 2v3a1 1 0 0 0 1 1h1a1 1 0 1 0 0-2v-3a1 1 0 0 0-1-1H9Z" clip-rule="evenodd" /></svg>
                                <span class="info-tooltip">
                                    Tells the AI whether to comment on building ('Builds') or just cover ('Zero Build'). This improves commentary.
                                </span>
                            </div>
                            <!-- Tooltip End -->
                        </label>
                        <select id="game-mode-select" class="w-full p-2 rounded-md bg-gray-700 text-white border border-gray-600">
                            <option value="zero_build">Zero Build</option>
                            <option value="builds">Normal (Builds)</option>
                        </select>
                    </div>
                    <div>
                        <label for="caster-voice-select" class="block text-sm font-medium text-gray-400 mb-1 flex items-center gap-1">
                           <span>Commentator Voice</span>
                            <!-- Tooltip Start -->
                            <div class="relative">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4 text-gray-500 cursor-pointer"><path fill-rule="evenodd" d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-7-4a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM9 9a1 1 0 0 0 0 2v3a1 1 0 0 0 1 1h1a1 1 0 1 0 0-2v-3a1 1 0 0 0-1-1H9Z" clip-rule="evenodd" /></svg>
                                <span class="info-tooltip">
                                    Selects the browser's built-in voice for the AI. This provides 'instant' audio with no network lag.
                                </span>
                            </div>
                            <!-- Tooltip End -->
                        </label>
                        <select id="caster-voice-select" class="w-full p-2 rounded-md bg-gray-700 text-white border border-gray-600">
                            <option value="">Loading voices...</option>
                        </select>
                    </div>
                </div>

                <!-- Control Buttons -->
                <div class="pt-2 space-y-4">
                    <button id="test-audio-btn" class="btn-secondary p-3 rounded-lg shadow-lg w-full flex items-center justify-center gap-2" onclick="testAudio()">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5"><path d="M7.7,3.1C8.1,2.7,8.7,2.7,9.1,3.1L11.6,5.6c0.4,0.4,0.4,1,0,1.4C11.4,7.2,11,7.2,10.6,6.9L8.4,4.7L6.2,6.9C6,7.2,5.4,7.2,5.1,6.9c-0.4-0.4-0.4-1,0-1.4L7.7,3.1z M12.3,16.9c-0.4,0.4-1,0.4-1.4,0L8.4,14.4c-0.4-0.4-0.4-1,0-1.4C8.6,12.8,9,12.8,9.4,13.1l2.1,2.1l2.1-2.1c0.4-0.4,1-0.4,1.4,0c0.4,0.4,0.4,1,0,1.4L12.3,16.9z"/></svg>
                        Test Audio
                    </button>
                    
                    <button id="mic-toggle-btn" class="btn-secondary w-full p-3 rounded-lg shadow-lg flex items-center justify-center gap-2" onclick="toggleMicListening()">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5"><path d="M7.5 3a4.5 4.5 0 0 1 4.981 4.195c.023.217.023.438.002.651l.002-.002a5.002 5.002 0 0 1-2.06 4.152L10 11.83l.06-.03a4.5 4.5 0 0 1 5.712-2.318c.51.188.98.45 1.402.774A6.5 6.5 0 0 0 10 1.5a6.5 6.5 0 0 0-6.48 6.074c.33-.207.69-.373 1.08-.501A4.5 4.5 0 0 1 7.5 3zM2 10a8 8 0 0 1 8-8 8 8 0 0 1 8 8c0 2.663-1.3 5.053-3.32 6.481l-.004.003L14.5 18H5.5l-1.178-1.517-.004-.003A8.002 8.002 0 0 1 2 10z"/></svg>
                        Start Listening to Mic
                    </button>
                    <div class="flex items-center justify-center gap-1">
                        <p id="mic-status" class="text-xs text-center text-gray-500">Mic is Idle. (Uses System Default Input)</p>
                        <!-- Tooltip Start -->
                        <div class="relative">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4 text-gray-500 cursor-pointer"><path fill-rule="evenodd" d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-7-4a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM9 9a1 1 0 0 0 0 2v3a1 1 0 0 0 1 1h1a1 1 0 1 0 0-2v-3a1 1 0 0 0-1-1H9Z" clip-rule="evenodd" /></svg>
                            <span class="info-tooltip">
                                The Speech-to-Text (STT) *always* uses your 'System Default' mic. Set this in your Mac/PC settings.
                            </span>
                        </div>
                        <!-- Tooltip End -->
                    </div>
                </div>
            </div>

            <!-- Twitch Chat Card -->
            <div id="twitch-card" class="card rounded-xl p-4 space-y-4">
                <div class="flex justify-between items-center mb-2">
                    <h2 class="text-xl font-bold text-gray-300">Twitch Chat Integration</h2>
                    <p id="twitch-status" class="status-disconnected text-sm">Status: Disconnected</p>
                </div>
                <div>
                    <label for="twitch-channel-input" class="block text-sm font-medium text-gray-400 mb-1 flex items-center gap-1">
                        <span>Twitch Channel Name</span>
                        <!-- Tooltip Start -->
                        <div class="relative">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4 text-gray-500 cursor-pointer"><path fill-rule="evenodd" d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-7-4a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM9 9a1 1 0 0 0 0 2v3a1 1 0 0 0 1 1h1a1 1 0 1 0 0-2v-3a1 1 0 0 0-1-1H9Z" clip-rule="evenodd" /></svg>
                            <span class="info-tooltip">
                                The AI will read and react to the *sentiment* of your Twitch chat.
                            </span>
                        </div>
                        <!-- Tooltip End -->
                    </label>
                    <input type="text" id="twitch-channel-input" placeholder="e.g., your_channel_name" class="w-full p-2 rounded-md bg-gray-700 text-white border border-gray-600">
                </div>
                <button id="twitch-connect-btn" class="btn-secondary w-full p-3 rounded-lg shadow-lg" onclick="toggleTwitchConnection()" disabled>
                    Connect to Twitch Chat
                </button>
                <div id="chat-feed-box">
                    <p class="italic text-gray-500">Twitch chat messages will appear here...</p>
                </div>
            </div>

        </div>

        <!-- Right Column: Game & Commentary -->
        <div class="lg:col-span-2 space-y-6">
            <!-- Game Container -->
            <div id="game-container" class="card rounded-xl p-4 space-y-4">
                <div class="scene-container rounded-lg overflow-hidden border-4 border-sky-400" id="image-frame-container">
                    <video id="game-screen-video" class="game-screen-video" autoplay playsinline muted></video>
                </div>

                <div class="flex flex-col sm:flex-row gap-4">
                    <button id="start-btn" class="btn-primary p-3 rounded-lg shadow-lg flex-1 flex items-center justify-center gap-2" onclick="startStream()" disabled>
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5"><path fill-rule="evenodd" d="M7.02,3.93C7.45,3.67,8,3.9,8,4.39V15.61c0,0.49-0.55,0.72-0.98,0.46L2.1,12.43c-0.38-0.23-0.6-0.65-0.6-1.11V8.69c0-0.46,0.22-0.88,0.6-1.11L7.02,3.93z M10,4.39V15.61c0,0.49,0.55,0.72,0.98,0.46l4.9-3.63c0.38-0.23,0.6-0.65,0.6-1.11V8.69c0-0.46-0.22-0.88-0.6-1.11L10.98,3.93C10.55,3.67,10,3.9,10,4.39z" clip-rule="evenodd" /></svg>
                        START LIVE COMMENTARY
                    </button>
                    <button id="stop-btn" class="btn-danger p-3 rounded-lg shadow-lg flex-1 flex items-center justify-center gap-2" onclick="stopStream()" disabled>
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5"><path fill-rule="evenodd" d="M8.5,3C9.3,3,10,3.7,10,4.5V15.5C10,16.3,9.3,17,8.5,17h-0.8C6.8,17,6,16.3,6,15.5V4.5C6,3.7,6.8,3,7.8,3H8.5z M12.3,3C13.1,3,13.8,3.7,13.8,4.5V15.5C13.8,16.3,13.1,17,12.3,17h-0.8c-0.9,0-1.7-0.7-1.7-1.5V4.5C10.8,3.7,11.5,3,12.3,3H12.3z" clip-rule="evenodd" /></svg>
                        STOP STREAM
                    </button>
                </div>
            </div>

            <!-- Commentary Card -->
            <div id="commentary-card" class="card rounded-xl p-4 space-y-4">
                <div id="caster-box" class="commentary-output">
                    <h3 class="font-bold text-sky-300 mb-2">Hype Caster Says:</h3>
                    <p id="commentary-text" class="text-xl italic text-gray-300">Awaiting stream start...</p>
                    <div id="loading-indicator" class="hidden flex items-center space-x-2 mt-2">
                        <div class="w-3 h-3 bg-sky-400 rounded-full animate-pulse"></div>
                        <span class="text-xs text-sky-300">Caster thinking...</span>
                    </div>
                </div>
                <!-- STT Output Box -->
                <div id="stt-box" class="stt-output">
                    <h3 class="font-bold text-purple-300 mb-2">Your Mic (STT):</h3>
                    <p id="stt-text" class="text-lg italic text-gray-400">...</p>
                </div>
            </div>
        </div>
        
        <canvas id="hidden-canvas" style="display: none;"></canvas>
    </div>

    <script type="module">
        // --- Global State ---
        let isStreaming = false;
        let isCameraActive = false;
        let mediaStream = null;
        let gameLoopId = null;
        let chatLoopId = null;
        let audioLoopId = null;
        let currentFocusAreaIndex = 0;
        const FOCUS_AREAS = ["Action and Health", "Movement and Strategy", "Loot and Building/Cover"];
        const TEST_AUDIO_TEXT = "This is a quick audio test. Sound path confirmed.";
        const GAME_LOOP_DELAY = 4000; // 4 seconds
        const CHAT_LOOP_DELAY = 30000; // 30 seconds
        const AUDIO_LOOP_DELAY = 250; // 4 times per second
        let currentApiKey = "";

        // --- Decoupled Audio State ---
        let audioQueue = [];
        let isAudioLoopRunning = false;
        let systemVoices = [];

        // --- Twitch State ---
        let twitchClient = null;
        let chatMessageHistory = [];
        const PROFANITY_FILTER = ["damn", "hell", "jerk", "stupid"]; // Simple example filter

        // --- Speech-to-Text (STT) State ---
        let speechRecognition = null;
        let userWantsToListen = false; // The user's intended state
        let isListeningToMic = false; // The actual state of the API

        // --- DOM Elements ---
        const gameScreenVideo = document.getElementById('game-screen-video');
        const startBtn = document.getElementById('start-btn');
        const stopBtn = document.getElementById('stop-btn');
        const activateCameraBtn = document.getElementById('activate-camera-btn');
        const testAudioBtn = document.getElementById('test-audio-btn');
        const imageFrameContainer = document.getElementById('image-frame-container');
        const videoSelect = document.getElementById('video-input-select');
        const gameModeSelect = document.getElementById('game-mode-select');
        const casterVoiceSelect = document.getElementById('caster-voice-select');
        const hiddenCanvas = document.getElementById('hidden-canvas');
        const commentaryText = document.getElementById('commentary-text');
        const loadingIndicator = document.getElementById('loading-indicator');
        const casterBox = document.getElementById('caster-box');
        const sttText = document.getElementById('stt-text'); // STT output
        const twitchChannelInput = document.getElementById('twitch-channel-input');
        const twitchConnectBtn = document.getElementById('twitch-connect-btn');
        const chatFeedBox = document.getElementById('chat-feed-box');
        const twitchStatus = document.getElementById('twitch-status');
        const apiKeyInput = document.getElementById('api-key-input');
        const micToggleBtn = document.getElementById('mic-toggle-btn');
        const micStatus = document.getElementById('mic-status');

        // --- Commentator Definitions ---
        const FORTNITE_CONTEXT = `
            About Fortnite: This is a fast-paced Battle Royale game.
            - Health: Players have a green Health bar and a blue Shield bar. "Cracked" means shields are broken.
            - Storm: A purple storm closes in, forcing players into a smaller circle.
            - Loot: Players find weapons of different rarities (Gray, Green, Blue, Purple, Gold).
            - Victory Royale: The last player or team standing wins.
        `;

        // --- Initialization ---
        window.onload = initializeApplication;

        function initializeApplication() {
            populateDeviceLists();
            loadBrowserVoices();
            initializeSpeechRecognition();

            // "Bomb-proof" TMI.js loader
            const tmiCheckInterval = setInterval(() => {
                if (typeof window.tmi !== 'undefined' && window.tmi.Client) { 
                    clearInterval(tmiCheckInterval);
                    twitchConnectBtn.disabled = false;
                    console.log("TMI.js is loaded and ready.");
                } else {
                    console.log("Waiting for TMI.js to load...");
                }
            }, 250);
        }
        
        // --- Browser Voice Loading ---
        function loadBrowserVoices() {
            function populateVoiceList() {
                systemVoices = window.speechSynthesis.getVoices();
                casterVoiceSelect.innerHTML = '';
                
                if (systemVoices.length === 0) {
                     casterVoiceSelect.innerHTML = '<option value="">No voices found</option>';
                     return;
                }

                const englishVoices = systemVoices.filter(voice => voice.lang.includes('en'));

                englishVoices.forEach(voice => {
                    const option = document.createElement('option');
                    option.textContent = `${voice.name} (${voice.lang})`;
                    option.setAttribute('data-lang', voice.lang);
                    option.setAttribute('data-name', voice.name);
                    casterVoiceSelect.appendChild(option);
                });
                
                const savedVoiceName = localStorage.getItem('fortniteCasterVoice');
                const selectedVoice = englishVoices.find(v => v.name === savedVoiceName);
                
                if (savedVoiceName && selectedVoice) {
                    casterVoiceSelect.value = selectedVoice.textContent;
                } else if (englishVoices.length > 0) {
                    let defaultVoice = englishVoices.find(v => v.name.includes('Google') && v.lang.includes('en-GB')) || 
                                       englishVoices.find(v => v.name.includes('Google') && v.lang.includes('en-US')) || 
                                       englishVoices.find(v => v.lang === 'en-GB') || 
                                       englishVoices.find(v => v.lang === 'en-US') || 
                                       englishVoices[0];
                    casterVoiceSelect.value = `${defaultVoice.name} (${defaultVoice.lang})`;
                }
                
                casterVoiceSelect.onchange = () => {
                    const selectedVoice = casterVoiceSelect.options[casterVoiceSelect.selectedIndex];
                    localStorage.setItem('fortniteCasterVoice', selectedVoice.getAttribute('data-name'));
                };
            }

            populateVoiceList();
            if (window.speechSynthesis.onvoiceschanged !== undefined) {
                window.speechSynthesis.onvoiceschanged = populateVoiceList;
            }
        }

        // --- Device and Settings Persistence ---
        function loadSettings() {
            const savedApiKey = localStorage.getItem('fortniteCasterApiKey');
            if (savedApiKey) {
                apiKeyInput.value = savedApiKey;
                currentApiKey = savedApiKey;
            }

            const savedVideo = localStorage.getItem('fortniteCasterVideo');
            const savedGameMode = localStorage.getItem('fortniteCasterGameMode') || 'zero_build'; // DEFAULT TO ZERO BUILD
            const savedTwitchChannel = localStorage.getItem('fortniteCasterTwitchChannel');

            if (savedVideo && Array.from(videoSelect.options).some(opt => opt.value === savedVideo)) {
                videoSelect.value = savedVideo;
            }
            if (savedTwitchChannel) {
                twitchChannelInput.value = savedTwitchChannel;
            }
            
            gameModeSelect.value = savedGameMode;

            apiKeyInput.onchange = () => {
                currentApiKey = apiKeyInput.value;
                localStorage.setItem('fortniteCasterApiKey', currentApiKey);
            };

            videoSelect.onchange = () => localStorage.setItem('fortniteCasterVideo', videoSelect.value);
            gameModeSelect.onchange = () => localStorage.setItem('fortniteCasterGameMode', gameModeSelect.value);
            twitchChannelInput.onchange = () => localStorage.setItem('fortniteCasterTwitchChannel', twitchChannelInput.value);
        }

        async function populateDeviceLists() {
            try {
                // Request permissions for both audio and video
                await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                const devices = await navigator.mediaDevices.enumerateDevices();
                
                videoSelect.innerHTML = '<option value="">-- Select Camera/Screen --</option>';

                devices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `Unknown ${device.kind}`;

                    if (device.kind === 'videoinput') {
                        videoSelect.appendChild(option);
                    }
                });
                loadSettings();
            } catch (err) {
                console.error("Error enumerating devices:", err);
                if (err.name === "NotAllowedError" || err.name === "PermissionDeniedError") {
                    alert("Permissions for camera and microphone are required to use this app.");
                }
                videoSelect.innerHTML = '<option value="">Permission required</option>';
            }
        }

        // --- Camera and Audio Control ---
        window.activateCamera = async function() {
            const videoDeviceId = videoSelect.value;
            if (!videoDeviceId) {
                alert("Please select a video input source first.");
                return;
            }

            try {
                if (mediaStream) {
                    mediaStream.getTracks().forEach(track => track.stop());
                }
                
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    video: { deviceId: videoDeviceId },
                    audio: false
                });
                gameScreenVideo.srcObject = mediaStream;
                await gameScreenVideo.play();
                isCameraActive = true;
                startBtn.disabled = false;
                activateCameraBtn.disabled = true;
                activateCameraBtn.textContent = 'Active';
                activateCameraBtn.classList.remove('btn-secondary');
                activateCameraBtn.classList.add('btn-primary'); // Change color to green
                imageFrameContainer.classList.add('pulsing');
            } catch (error) {
                console.error("Error activating camera:", error);
                alert(`Failed to start video stream: ${error.message}. Check browser permissions or try a different camera.`);
                isCameraActive = false;
            }
        }

        window.testAudio = async function() {
            if (window.speechSynthesis.speaking) return; 
            
            casterBox.classList.remove('caster-box-error');
            commentaryText.textContent = "Playing test sound...";

            try {
                await playTextWithSpeechSynthesis(TEST_AUDIO_TEXT, 'game'); // Use 'game' source for styling
                commentaryText.textContent = "Test sound played. Check your audio output.";
            } catch (error) {
                console.error("Audio test failed:", error);
                commentaryText.textContent = `[ERROR] Audio test failed. ${error.message}`;
                casterBox.classList.add('caster-box-error');
            }
        }

        // --- TMI.js Twitch Chat ---
        window.toggleTwitchConnection = function() {
            if (typeof tmi === 'undefined' || !tmi.Client) {
                alert("TMI.js library is still loading. Please wait a moment.");
                return;
            }

            if (twitchClient && twitchClient.readyState() === "OPEN") {
                twitchClient.disconnect();
            } else {
                const channelName = twitchChannelInput.value.trim().toLowerCase();
                if (!channelName) {
                    alert("Please enter a Twitch channel name.");
                    return;
                }
                
                twitchChannelInput.disabled = true;
                twitchConnectBtn.textContent = "Connecting...";
                twitchConnectBtn.disabled = true;
                twitchStatus.textContent = "Status: Connecting...";
                twitchStatus.className = "status-connecting text-sm";
                chatFeedBox.innerHTML = '';
                addChatMessageToFeed(null, `Connecting to #${channelName}...`, "#ffffff");

                twitchClient = new window.tmi.Client({
                    options: { debug: false },
                    channels: [ channelName ]
                });

                twitchClient.on('connected', () => {
                    console.log("Twitch client connected");
                    twitchConnectBtn.textContent = "Disconnect from Chat";
                    twitchConnectBtn.classList.remove("btn-secondary");
                    twitchConnectBtn.classList.add("btn-danger");
                    twitchConnectBtn.disabled = false;
                    addChatMessageToFeed(null, `Successfully connected to #${channelName}!`, "#10b981");
                    twitchStatus.textContent = "Status: Connected";
                    twitchStatus.className = "status-connected text-sm";
                });

                // "Bomb-proof" message handler
                twitchClient.on('message', (channel, tags, message, self) => {
                    // Ignore bot's own messages
                    if (self) return; 
                    
                    // "Bomb-proof" check: Only process valid user chat messages
                    if (tags && tags['display-name']) {
                        const lowerMessage = message.toLowerCase();
                        const isInappropriate = PROFANITY_FILTER.some(word => lowerMessage.includes(word));
                        if (isInappropriate) {
                            console.log(`Filtered inappropriate message from ${tags['display-name']}`);
                            return;
                        }
                        
                        addChatMessageToFeed(tags['display-name'], message, tags.color);
                        
                        chatMessageHistory.push(`${tags['display-name']}: ${message}`);
                        if (chatMessageHistory.length > 15) {
                            chatMessageHistory.shift();
                        }
                    } else {
                        // Safely ignore system messages (joins, parts, etc.)
                        console.log("Ignoring system message:", message);
                    }
                });
                
                twitchClient.on('disconnected', (reason) => {
                    console.log("Twitch client disconnected");
                    addChatMessageToFeed(null, `Disconnected from Twitch. ${reason || ''}`, "#ef4444");
                    twitchStatus.textContent = "Status: Disconnected";
                    twitchStatus.className = "status-disconnected text-sm";
                    twitchConnectBtn.textContent = "Connect to Twitch Chat";
                    twitchConnectBtn.classList.remove("btn-danger");
                    twitchConnectBtn.classList.add("btn-secondary");
                    twitchConnectBtn.disabled = false;
                    twitchChannelInput.disabled = false;
                    twitchClient = null;
                });

                twitchClient.connect().catch(err => {
                    console.error("Twitch connection error:", err);
                    addChatMessageToFeed(null, `Failed to connect: ${err}`, "#ef4444");
                    twitchStatus.textContent = "Status: Failed";
                    twitchStatus.className = "status-disconnected text-sm";
                    twitchConnectBtn.textContent = "Connect to Twitch Chat";
                    twitchConnectBtn.disabled = false;
                    twitchChannelInput.disabled = false;
                    twitchClient = null;
                });
            }
        }

        function addChatMessageToFeed(username, message, color) {
            // Check if chat box is scrolled to the bottom
            const isScrolledToBottom = chatFeedBox.scrollHeight - chatFeedBox.clientHeight <= chatFeedBox.scrollTop + 1;

            const chatLine = document.createElement('p');
            
            if (username) {
                const usernameSpan = document.createElement('span');
                usernameSpan.className = 'chat-username';
                usernameSpan.style.color = color || '#ffffff';
                usernameSpan.textContent = `${username}: `;
                chatLine.appendChild(usernameSpan);
            } else {
                chatLine.style.fontStyle = 'italic';
                chatLine.style.color = color || '#888888';
            }

            chatLine.appendChild(document.createTextNode(message));
            chatFeedBox.appendChild(chatLine);
            
            // Auto-scroll only if user was already at the bottom
            if(isScrolledToBottom) {
                chatFeedBox.scrollTop = chatFeedBox.scrollHeight;
            }
        }

        // --- Speech-to-Text (STT) ---
        function initializeSpeechRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                micStatus.textContent = "STT not supported by this browser.";
                micToggleBtn.disabled = true;
                return;
            }

            speechRecognition = new SpeechRecognition();
            speechRecognition.continuous = true;
            speechRecognition.interimResults = true; // Show interim results for live feedback

            speechRecognition.onstart = () => {
                isListeningToMic = true;
                micToggleBtn.textContent = "Stop Listening";
                micToggleBtn.classList.remove("btn-secondary");
                micToggleBtn.classList.add("btn-danger");
                micStatus.textContent = "Listening... (Using System Default Mic)";
                micStatus.className = "text-xs text-center status-connected mt-1";
            };

            speechRecognition.onend = () => {
                isListeningToMic = false;
                micToggleBtn.textContent = "Start Listening to Mic";
                micToggleBtn.classList.remove("btn-danger");
                micToggleBtn.classList.add("btn-secondary");
                micStatus.textContent = "Mic is Idle. (Uses System Default Mic)";
                micStatus.className = "text-xs text-center text-gray-500 mt-1";
                
                // "Bomb-proof" toggle: Only restart if the user *wants* us to be listening
                if (userWantsToListen) {
                    console.log("STT ended, auto-restarting...");
                    setTimeout(() => {
                        try { speechRecognition.start(); } catch(e) { console.error("STT restart failed", e); }
                    }, 100);
                }
            };

            speechRecognition.onerror = (event) => {
                 // "Bomb-proof" fix: "no-speech" is not a fatal error.
                if (event.error === 'no-speech') {
                    console.log("STT: No speech detected, will restart if needed.");
                    // This is normal, STT will restart on 'onend' if userWantsToListen
                    return; 
                }
                
                // "not-allowed" is a fatal permission error
                if (event.error === 'not-allowed') {
                     alert("Mic permission denied. STT cannot start.");
                     userWantsToListen = false; // Stop trying to restart
                }

                console.error("Speech recognition error:", event.error);
                micStatus.textContent = `Mic Error: ${event.error}`;
                micStatus.className = "text-xs text-center status-disconnected mt-1";
                isListeningToMic = false; // Ensure state is correct
            };

            speechRecognition.onresult = (event) => {
                let interimTranscript = '';
                let finalTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        finalTranscript += event.results[i][0].transcript;
                    } else {
                        interimTranscript += event.results[i][0].transcript;
                    }
                }

                // Update the STT text box with interim (live) results
                sttText.textContent = interimTranscript || '...';

                // Process the final transcript
                if (finalTranscript.trim().length > 3) {
                    console.log("Streamer said:", finalTranscript);
                    sttText.textContent = finalTranscript;
                    if(isStreaming) { // Only send to AI if stream is active
                        processStreamerComment(finalTranscript);
                    }
                }
            };
        }

        window.toggleMicListening = function() {
            if (!speechRecognition) {
                alert("Speech Recognition is not supported by your browser.");
                return;
            }
            
            // "Bomb-proof" permission check
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(stream => {
                    // We don't need to *use* the stream, just get permission.
                    stream.getTracks().forEach(track => track.stop());
                    
                    if (isListeningToMic) {
                        userWantsToListen = false; // User *intends* to stop
                        speechRecognition.stop();
                    } else {
                        userWantsToListen = true; // User *intends* to start
                        try {
                            speechRecognition.start();
                        } catch(e) {
                            console.error("Mic start failed", e);
                            micStatus.textContent = "Mic Error: Could not start.";
                        }
                    }
                })
                .catch(err => {
                    console.error("Mic permission error:", err);
                    alert("Failed to get mic permission. Please allow microphone access.");
                    micStatus.textContent = "Mic Error: Permission Denied.";
                });
        };

        // --- Stream Control (Decoupled Loops, Instant Speech) ---
        window.startStream = async function() {
            if (isStreaming || !isCameraActive) return;

            if (!getApiKey(false)) { // Check for key without throwing error
                alert("Please enter your Gemini API Key in the setup box first.");
                casterBox.classList.add('caster-box-error');
                commentaryText.textContent = "[FATAL ERROR] API Key is missing. Stream stopped.";
                return;
            }

            try {
                // "Warm up" the speech engine on the user's click
                window.speechSynthesis.speak(new SpeechSynthesisUtterance(""));
            } catch (e) {
                console.error("SpeechSynthesis warmup failed:", e);
                alert("Could not start audio. Please click the page and try again.");
                return;
            }
            
            isStreaming = true;
            isAudioLoopRunning = true;
            startBtn.disabled = true;
            stopBtn.disabled = false;
            
            casterBox.classList.remove('caster-box-error');
            commentaryText.textContent = "Stream started. Analyzing first frame...";
            
            // Start all three loops
            runGameLoop();
            runAudioLoop();
            runChatReactionLoop();
        }
        
        async function runGameLoop() {
            if (!isStreaming) return; 

            try {
                await processFrameForCommentary();
            } catch (error) {
                console.error("Error in Game Loop:", error);
                if (error.message.startsWith("FATAL_AUTH_ERROR")) {
                    commentaryText.textContent = `[FATAL ERROR] ${error.message}. Stream stopped. Check your API Key.`;
                    casterBox.classList.add('caster-box-error');
                    stopStream(); 
                    return; 
                } else {
                    commentaryText.textContent = `[ERROR] ${error.message}`;
                    casterBox.classList.add('caster-box-error');
                }
            }

            if (isStreaming) {
                gameLoopId = setTimeout(runGameLoop, GAME_LOOP_DELAY);
            }
        }

        async function runChatReactionLoop() {
            if (!isStreaming) return; 

            try {
                if (twitchClient && twitchClient.readyState() === "OPEN" && chatMessageHistory.length > 0) {
                    await processChatReaction();
                }
            } catch (error) {
                console.error("Error in Chat Loop:", error);
                console.error(`[CHAT AI ERROR] ${error.message}`);
            }

            if (isStreaming) {
                chatLoopId = setTimeout(runChatReactionLoop, CHAT_LOOP_DELAY); 
            }
        }

        async function runAudioLoop() {
            if (!isAudioLoopRunning) return;

            if (audioQueue.length > 0 && !window.speechSynthesis.speaking) {
                const { text, source } = audioQueue.shift(); 
                
                try {
                    // Always show AI text in the main box
                    commentaryText.textContent = text;
                    // Set style based on who is "talking"
                    casterBox.classList.remove('caster-box-error', 'caster-box-active', 'caster-box-chat', 'caster-box-streamer');
                    if (source === 'chat') {
                        casterBox.classList.add('caster-box-chat');
                    } else if (source === 'streamer') {
                        casterBox.classList.add('caster-box-streamer');
                    } else {
                        casterBox.classList.add('caster-box-active');
                    }
                
                    await playTextWithSpeechSynthesis(text, source);

                } catch (error) {
                    console.error("Error in Audio Loop (Speech):", error);
                    commentaryText.textContent = `[SPEECH ERROR] ${error.message}`;
                    casterBox.classList.add('caster-box-error');
                }
            }
            
            if (isAudioLoopRunning) {
                audioLoopId = setTimeout(runAudioLoop, AUDIO_LOOP_DELAY); 
            }
        }

        window.stopStream = function() {
            if (!isStreaming) return;
            
            isStreaming = false;
            isAudioLoopRunning = false;
            if (gameLoopId) clearTimeout(gameLoopId);
            if (chatLoopId) clearTimeout(chatLoopId); 
            if (audioLoopId) clearTimeout(audioLoopId);
            
            window.speechSynthesis.cancel();
            
            startBtn.disabled = false;
            stopBtn.disabled = true;
            commentaryText.textContent = "Stream stopped. Camera feed is still active.";
            loadingIndicator.classList.add('hidden');
            casterBox.classList.remove('caster-box-active', 'caster-box-chat', 'caster-box-streamer');
            
            audioQueue = [];
            chatMessageHistory = [];
        }

        // --- Core Processors ---
        async function processFrameForCommentary() {
            // Don't analyze game frame if AI is busy talking
            if (window.speechSynthesis.speaking) return; 
            
            loadingIndicator.classList.remove('hidden');
            casterBox.classList.remove('caster-box-error');
            
            const base64Image = captureFrame();
            if (!base64Image) {
                loadingIndicator.classList.add('hidden');
                throw new Error("Could not capture frame.");
            }

            const gameMode = gameModeSelect.value;
            const focusArea = FOCUS_AREAS[currentFocusAreaIndex];
            currentFocusAreaIndex = (currentFocusAreaIndex + 1) % FOCUS_AREAS.length;

            loadingIndicator.classList.remove('hidden');
            const commentary = await generateCommentary(base64Image, gameMode, focusArea);
            loadingIndicator.classList.add('hidden');
            
            if (commentary.text) {
                // Add to *end* of queue
                audioQueue.push({ text: commentary.text, source: 'game' });
            }
        }

        async function processChatReaction() {
            const chatMessages = chatMessageHistory.join('\n');
            chatMessageHistory = []; 
            
            const reactionText = await generateChatReaction(chatMessages);
            
            if (reactionText) {
                // Add to *end* of queue
                audioQueue.push({ text: reactionText, source: 'chat' });
            }
        }
        
        async function processStreamerComment(transcript) {
            const reactionText = await generateStreamerReaction(transcript);
            if (reactionText) {
                // Add to the *front* of the queue to make it the next thing spoken
                audioQueue.unshift({ text: reactionText, source: 'streamer' });
                
                // Immediately interrupt any game analysis that might be speaking
                if (window.speechSynthesis.speaking) {
                    window.speechSynthesis.cancel();
                }
            }
        }


        function captureFrame() {
            try {
                hiddenCanvas.width = gameScreenVideo.videoWidth;
                hiddenCanvas.height = gameScreenVideo.videoHeight;
                const ctx = hiddenCanvas.getContext('2d');
                ctx.drawImage(gameScreenVideo, 0, 0, hiddenCanvas.width, hiddenCanvas.height);
                // Use JPEG with quality 0.7 for speed
                return hiddenCanvas.toDataURL('image/jpeg', 0.7);
            } catch (e) {
                console.error("Frame capture error:", e);
                return null;
            }
        }

        // --- Instant Audio Function ---
        async function playTextWithSpeechSynthesis(textToSpeak, source) {
            return new Promise((resolve, reject) => {
                if (window.speechSynthesis.speaking) {
                    console.warn("SpeechSynthesis was already speaking. Cancelling.");
                    window.speechSynthesis.cancel(); 
                }

                const utterance = new SpeechSynthesisUtterance(textToSpeak);
                
                const selectedOption = casterVoiceSelect.options[casterVoiceSelect.selectedIndex];
                if (selectedOption) {
                    const selectedVoiceName = selectedOption.getAttribute('data-name');
                    if (selectedVoiceName) {
                        const voice = systemVoices.find(v => v.name === selectedVoiceName);
                        if (voice) {
                            utterance.voice = voice;
                        }
                    }
                }
                
                // Note: We cannot route browser speech synth to a specific audio output.
                // It will *always* use the system/browser default audio output.
                
                utterance.pitch = 1.2;
                utterance.rate = 1.1;

                // Adjust rate/pitch based on source for more personality
                if (source === 'game') {
                    utterance.rate = 1.15; // Faster for game hype
                } else if (source === 'chat') {
                    utterance.pitch = 1.1;
                } else if (source === 'streamer') {
                    utterance.rate = 1.0; // More conversational
                    utterance.pitch = 1.1;
                }


                utterance.onend = () => {
                    casterBox.classList.remove('caster-box-active', 'caster-box-chat', 'caster-box-streamer');
                    resolve();
                };
                utterance.onerror = (e) => {
                    console.error("SpeechSynthesis error:", e);
                    casterBox.classList.remove('caster-box-active', 'caster-box-chat', 'caster-box-streamer');
                    if (e.error === 'interrupted' || e.error === 'canceled') {
                        console.warn("Speech was interrupted (normal).");
                        resolve(); // Not a fatal error
                    } else {
                        reject(new Error(`SpeechSynthesis error: ${e.error}`));
                    }
                };
                
                // "Bomb-proof" clear and speak
                window.speechSynthesis.cancel();
                setTimeout(() => window.speechSynthesis.speak(utterance), 50);
            });
        }


        // --- Gemini API Functions ---
        function getCasterSystemPrompt(gameMode, focusArea) {
            const gameModeContext = gameMode === 'builds' 
                ? "Players can build structures (walls, ramps) for defense. Building skill is critical."
                : "This is ZERO BUILD mode. Players cannot build. Focus on natural cover, positioning, and aim.";
            
            let focusInstruction = "";
            switch (focusArea) {
                case "Action and Health":
                    focusInstruction = "React to the fight! Is he winning or in danger? Call out eliminations with hype! If he's low health, build the tension! What's the *impact* of this moment?";
                    break;
                case "Movement and Strategy":
                    focusInstruction = "Is this a smart rotation? Is he taking high ground? Or is this a huge mistake? Call it like you see it! Is the storm a threat? What's the *intent*?";
                    break;
                case "Loot and Building/Cover":
                    focusInstruction = gameMode === 'builds'
                        ? "Is he a fast builder? Is that good defense? What's the *purpose* of that build?"
                        : "Is he using cover well? Did he just find a game-changing weapon? What's the *quality* of his position?";
                    break;
            }

            return `
                You are an e-sports entertainer and commentator for Fortnite.
                Your tone is electric, fast-paced, and you have a strong, fun personality.
                **CRITICAL RULE:** Never state the obvious. Do NOT describe simple actions like 'running' or 'reloading'. Your audience can see that. Your job is to call the *impact*, the *intent*, and the *risk*. Be opinionated.
                ${FORTNITE_CONTEXT}
                CURRENT GAME MODE: ${gameModeContext}
                YOUR CURRENT FOCUS: ${focusInstruction}
                Keep your commentary extremely short and punchy (10-15 words MAX).
                Respond ONLY with the commentary text.
            `;
        }

        function getChatSystemPrompt(messages) {
            return `
                You are an AI streamer assistant and co-host.
                The following are recent messages from the Twitch chat.
                Your job is to briefly (10-15 words MAX) and positively react to the *overall sentiment* of the chat.
                Do NOT read individual messages or user names.
                Be fun, engaging, and acknowledge the chat's energy.
                
                [RECENT CHAT MESSAGES]:
                ${messages}
                
                Respond ONLY with your reaction.
                Example (if chat is hyped): "Wow, chat is going absolutely wild right now!"
                Example (if chat is asking questions): "Chat is asking some great questions! Keep 'em coming!"
                Example (if chat is spamming emotes): "I see that emote spam! The hype is real!"
            `;
        }

        function getStreamerReactionSystemPrompt(transcript) {
            return `
                You are an AI co-host, casting a game with a human streamer.
                The streamer just said: "${transcript}"
                Your job is to provide a brief, supportive, or witty co-host reaction (10-15 words MAX).
                Do NOT just repeat what they said. Add to the conversation.
                Be fun and conversational.
                
                Respond ONLY with your reaction.
                Example (if streamer says "I'm healing up"): "Good call, that was a close one!"
                Example (if streamer says "Oh no, I missed the shot!"): "Ah, you'll get the next one! He's still close!"
                Example (if streamer says "Let's push this team"): "I'm with you! Let's go!"
            `;
        }


        function getApiKey(throwError = true) {
            if (!currentApiKey) {
                if (throwError) {
                    stopStream();
                    casterBox.classList.add('caster-box-error');
                    commentaryText.textContent = "[FATAL ERROR] API Key is missing. Stream stopped.";
                    throw new Error("FATAL_AUTH_ERROR: API Key is missing.");
                }
                return null;
            }
            return currentApiKey;
        }

        async function generateCommentary(base64Image, gameMode, focusArea) {
            const apiKey = getApiKey();
            if (!apiKey) return { text: null };
            
            const systemPrompt = getCasterSystemPrompt(gameMode, focusArea);
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

            const payload = {
                contents: [
                    {
                        role: "user",
                        parts: [
                            {
                                inlineData: {
                                    mimeType: 'image/jpeg',
                                    data: base64Image.split(',')[1]
                                }
                            },
                            { text: "Analyze this frame." }
                        ]
                    }
                ],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
            };
            
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    mode: 'cors',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    if (response.status === 401 || response.status === 403) {
                        throw new Error(`FATAL_AUTH_ERROR: Vision HTTP error! status: ${response.status}. Check your API Key.`);
                    }
                    throw new Error(`Vision HTTP error! status: ${response.status}`);
                }
                const result = await response.json();
                const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
                if (text) {
                    return { text };
                } else {
                    return { text: null };
                }
            } catch (error) {
                console.error("Gemini Commentary API Call Failed:", error);
                throw error;
            }
        }

        async function generateChatReaction(messages) {
            const apiKey = getApiKey();
            if (!apiKey) return null;
            
            const systemPrompt = getChatSystemPrompt(messages);
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

            const payload = {
                contents: [
                    {
                        role: "user",
                        parts: [ { text: "React to these chat messages." } ]
                    }
                ],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
            };
            
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    mode: 'cors',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    if (response.status === 401 || response.status === 403) {
                        throw new Error(`FATAL_AUTH_ERROR: Chat AI HTTP error! status: ${response.status}. Check your API Key.`);
                    }
                    throw new Error(`Chat AI HTTP error! status: ${response.status}`);
                }
                const result = await response.json();
                const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
                return text || null;
            } catch (error) {
                console.error("Gemini Chat Reaction API Call Failed:", error);
                throw error;
            }
        }
        
        async function generateStreamerReaction(transcript) {
            const apiKey = getApiKey();
            if (!apiKey) return null;
            
            const systemPrompt = getStreamerReactionSystemPrompt(transcript);
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

            const payload = {
                contents: [
                    {
                        role: "user",
                        parts: [ { text: "React to the streamer." } ]
                    }
                ],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
            };
            
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    mode: 'cors',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    if (response.status === 401 || response.status === 403) {
                        throw new Error(`FATAL_AUTH_ERROR: Streamer AI HTTP error! status: ${response.status}. Check your API Key.`);
                    }
                    throw new Error(`Streamer AI HTTP error! status: ${response.status}`);
                }
                const result = await response.json();
                const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
                return text || null;
            } catch (error) {
                console.error("Gemini Streamer Reaction API Call Failed:", error);
                throw error;
            }
        }
    </script>
</body>
</html>
